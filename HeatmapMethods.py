from functools import partial
import torch
import torch.nn.functional as nf

from methods.LRPG import LRPWithGradient
from utils import *
from methods.GradCAM import GradCAM
from methods.LayerCAM import LayerCAM
from methods.ScoreCAM import ScoreCAM
from methods.AblationCAM import AblationCAM
from methods.RelevanceCAM import RelevanceCAM
from methods.LRP import LRP_Generator
from methods.IG import IG
from methods.LIDDecomposer import *
from methods.SmoothTaylor import SmoothTaylor


def decode_stages_wrapper(stages):
    def wrapper(model):
        return decode_stages(model, stages)
    return wrapper
def identity_wrapper(what):
    def wrapper():
        return what
    return wrapper
# interface: method, layer_caller, **kwargs
# return: 2-order function
# 1: *func(model)
# 2: heatmap(x, y)
def method_caller(method_class, layer_caller, **kwargs):  # for class-like
    def model_caller(model):
        method = method_class(model, layer_caller(model), **kwargs)  # initialize
        def data_caller(x, y):
            return method(x, y)
        return data_caller
    return model_caller
def function_caller(method_name, layer_caller, **kwargs):  # for function
    def model_caller(model):
        def data_caller(x, y):
            return method_name(model, layer_caller(model), x, y, **kwargs)
        return data_caller
    return model_caller


# cam_dict = lambda model, layer: {'arch': model, 'layer_name': layer}

# the method interface, all methods must follow this:
# the method can call twice
# 1. the method first accept "model" parameter, create a callable function "_m = m(model)"
# 2. the heatmap generated by secondly calling "hm = _m(x,yc)"
heatmap_methods = {
    "None": None,
    # ========= temp test

    # ============================== Top level features
    # using 5 stage to refer different model layers:
    # suppose input layer is layer 0, features_0 of vgg16 is layer 1
    # referring stage 0 as input layer
    # VGG: 012345-> 0,5,10,17,24,31
    # VGG stages in module features(convs): 4,9,16,23,30
    # ResNet: 12345-> mp,l1,l2,l3,l4
    # GoogleNet:...
    # -------------------------- CAM series
    "GradCAM-s5": method_caller(GradCAM, decode_stages_wrapper(5), post_softmax=False, relu=True),
    "GradCAM-origin-s5": method_caller(GradCAM, decode_stages_wrapper(5), post_softmax=False, relu=False),
    # "SG-GradCAM-origin-s5": lambda model: partial(GradCAM(model, decode_stages(model, 5)).__call__, post_softmax=True, relu=False),
    "LayerCAM-s5": method_caller(LayerCAM, decode_stages_wrapper(5), post_softmax=False, relu_weight=True, relu=True),
    # --LayerCAM-origin-s5 == LRP-0-s5
    # "LayerCAM-origin-s5": lambda model: partial(LayerCAM(model, decode_stages(model, 5)).__call__, post_softmax=False, relu_weight=False, relu=False),
    # --SG-LayerCAM-origin-s5 == ST-LRP-0-s5
    # "SG-LayerCAM-origin-s5": lambda model: partial(LayerCAM(model, decode_stages(model, 5)).__call__,post_softmax=True, relu=False),
    "ScoreCAM-s5": method_caller(ScoreCAM, decode_stages_wrapper(5), post_softmax=True, relu=False),
    # "ScoreCAMpp-s5": lambda model: partial(ScoreCAM(model, decode_stages(model, 5)).__call__, post_softmax=False, relu=False, pp=True),
    # "ScoreCAMgpp-s5": lambda model: partial(ScoreCAM(model, decode_stages(model, 5)).__call__, post_softmax=True, relu=False, pp=True),
    # ----------------- others
    # "Random": lambda model: lambda x, y: heatmapNormalizeR(torch.randn((1,) + x.shape[-2:])),
    "AblationCAM-s5": lambda model: lambda x, y: AblationCAM(model, -1)(x, y, relu=False),
    "RelevanceCAM-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        RelevanceCAM(model)(x, y, backward_init='c', method='lrpzp', layer_num=-1)),
    # -- IG
    # "IG-s5": method_caller(IG, decode_stages_wrapper(5), post_softmax=False),
    # "SIG-s5": method_caller(IG, decode_stages_wrapper(5), post_softmax=True),
    # "SmoothTaylor-s5": lambda model: partial(SmoothTaylor(model, decode_stages(model, 5)).__call__, post_softmax=False),

    # ---------------------------- LRP series
    "LRP-0-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=31)),
    # -- LRP-C use LRP-0 in classifier, they are equivalent.
    # "LRP-C-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpc', layer_num=31)),
    # -- LRP-Z is nonsense
    # "LRP-Z-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpz', layer=-1)),
    # -- LRP-ZP has no edge highlight, but lack class discrimination
    "LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='normal', method='lrpzp', layer_num=-1)),
    # -- LRP-W2 all red
    # "LRP-W2-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpw2', layer=-1)),
    # -- Contrastive LRP (C-LRP) to bad often loss discrimination
    # "C-LRP-C-s5": lambda model: lambda x, y: interpolate_to_imgsize(  # c is unstable
    #     LRP_Generator(model)(x, y, backward_init='c', method='lrpc', layer_num=31)),
    "C-LRP-C2-s5": lambda model: lambda x, y: interpolate_to_imgsize(  # c2 is stable, interesting.
        LRP_Generator(model)(x, y, backward_init='c', method='lrpc2', layer_num=31)),
    # "C-LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='c', method='lrpzp', layer=31)),
    "SG-LRP-0-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=-1)),
    "SG-LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=31)),

    # ----------- new LID (Layer-wise Increment Decomposition) series
    # ----------- method improvement: increment(in middle/top), contrast(in top), nonlinearity(in middle/top)
    # -- LID series name convention: Init-LID-Type-Layer.
    # -- SIG-LID-Taylor-s5 means it is linear decompose, given sig init, ending at top feature layer
    # -- middle: increment, top: none
    # "LID-Taylor-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, s=5, bp=None, lin=1),
    # -- middle: nonlinear increment
    # "LID-IG-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, s=5, bp=None, lin=0),
    # -- top: contrastive increment, middle: increment
    # "ST-LID-Taylor-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=5, bp='st', linear=True),
    # -- top: contrastive increment, middle: nonlinear increment
    # "ST-LID-IG-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=5, bp='st', linear=False),
    # -- top: nonlinear contrastive increment, middle: increment
    "SIG-LID-Taylor-s5": method_caller(LID_wrapper, decode_stages_wrapper((5, )), LIN=1, BP='sig'),

    # -- full mixed, top: nonlinear contrastive increment, middle: nonlinear increment
    "SIG-LID-IG-s5": method_caller(LID_wrapper, decode_stages_wrapper((5, )), LIN=0, BP='sig'),

    # ------ LRP is in LID with reference point Y^L=0
    # -- contrastive increment
    # "ST-LRP-C-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='st', method='lrpc', layer_num=-1)),
    # -- nonlinear contrastive increment, full nonlinear contrast but not increment in middle
    # "SIG-LRP-C-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=-1)),
    # -- LRP cannot use nonlinear in middle.
    # "LRP-IG-s5": lambda model: lambda x, y: interpolate_to_imgsize(  # unstable all layers due to low values
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpig', layer=-1)),
    # "SIG-LRP-IG-s5": lambda model: lambda x, y: interpolate_to_imgsize(  # unstable
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpig', layer=-1)),

    # "ST-LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='st', method='lrpzp', layer=31)),
    # "SIG-LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer=-1)),

    # ===================== Middle level features
    # --------------- cam series
    # -- GradCAM s4 is nonsense
    # "GradCAM-s4": lambda model: partial(GradCAM(model, decode_stages(model, 4)).__call__, post_softmax=False, relu=True),
    # "GradCAM-s3": lambda model: partial(GradCAM(model, decode_stages(model, 3)).__call__, post_softmax=False, relu=True),
    # "GradCAM-s2": lambda model: partial(GradCAM(model, decode_stages(model, 2)).__call__, post_softmax=False, relu=True),
    # "GradCAM-s1": lambda model: partial(GradCAM(model, decode_stages(model, 1)).__call__, post_softmax=False, relu=True),
    # "GradCAM-origin-s4": lambda model: partial(GradCAM(model, decode_stages(model, 4)).__call__,post_softmax=False, relu=False),
    # "SG-GradCAM-origin-s4": lambda model: partial(GradCAM(model, decode_stages(model, 4)).__call__,post_softmax=True, relu=False),
    # "LayerCAM-s4": lambda model: partial(LayerCAM(model, decode_stages(model, 4)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s3": lambda model: partial(LayerCAM(model, decode_stages(model, 3)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s2": lambda model: partial(LayerCAM(model, decode_stages(model, 2)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s1": lambda model: partial(LayerCAM(model, decode_stages(model, 1)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-origin-s4": lambda model: partial(LayerCAM(model, decode_stages(model, 4)).__call__,post_softmax=False, relu=False),
    # "LayerCAM-origin-s3": lambda model: partial(LayerCAM(model, decode_stages(model, 3))).__call__,post_softmax=False, relu=False),
    # "LayerCAM-origin-s2": lambda model: partial(LayerCAM(model, decode_stages(model, 2))).__call__,post_softmax=False, relu=False),
    # "LayerCAM-origin-s1": lambda model: partial(LayerCAM(model, decode_stages(model, 1))).__call__,post_softmax=False, relu=False),
    # "SG-LayerCAM-origin-s4": lambda model: partial(LayerCAM(model, decode_stages(model, 4))).__call__,post_softmax=True, relu=False),
    # "SG-LayerCAM-origin-s3": lambda model: partial(LayerCAM(model, decode_stages(model, 3))).__call__,post_softmax=True, relu=False),
    # "SG-LayerCAM-origin-s2": lambda model: partial(LayerCAM(model, decode_stages(model, 2))).__call__,post_softmax=True, relu=False),
    # "SG-LayerCAM-origin-s1": lambda model: partial(LayerCAM(model, decode_stages(model, 1))).__call__,post_softmax=True, relu=False),
    # "ScoreCAM-s4": lambda model: partial(ScoreCAM(model, decode_stages(model, 4)).__call__, post_softmax=True, relu=False),
    # "ScoreCAM-s3": lambda model: partial(ScoreCAM(model, decode_stages(model, 3)).__call__, post_softmax=True, relu=False),
    # "ScoreCAM-s2": lambda model: partial(ScoreCAM(model, decode_stages(model, 2)).__call__, post_softmax=True, relu=False),
    # "ScoreCAM-s1": lambda model: partial(ScoreCAM(model, decode_stages(model, 1)).__call__, post_softmax=True, relu=False),
    # -- lower layer ig is bad
    # "IG-s4": method_caller(IG, decode_stages_wrapper(4), post_softmax=False),
    # "IG-s3": method_caller(IG, decode_stages_wrapper(3), post_softmax=False),
    # "IG-s2": method_caller(IG, decode_stages_wrapper(2), post_softmax=False),
    # "IG-s1": method_caller(IG, decode_stages_wrapper(1), post_softmax=False),
    "SIG-s4": method_caller(IG, decode_stages_wrapper(4), post_softmax=True),
    "SIG-s3": method_caller(IG, decode_stages_wrapper(3), post_softmax=True),
    "SIG-s2": method_caller(IG, decode_stages_wrapper(2), post_softmax=True),
    "SIG-s1": method_caller(IG, decode_stages_wrapper(1), post_softmax=True),
    # also noisy at step=10, step=30 noisy, step=100 oom
    # "SmoothTaylor-s4": lambda model: partial(SmoothTaylor(model, decode_stages(model, 4)).__call__, post_softmax=False),
    # "SmoothTaylor-s3": lambda model: partial(SmoothTaylor(model, decode_stages(model, 3)).__call__, post_softmax=False),
    # "SmoothTaylor-s2": lambda model: partial(SmoothTaylor(model, decode_stages(model, 2)).__call__, post_softmax=False),
    # "SmoothTaylor-s1": lambda model: partial(SmoothTaylor(model, decode_stages(model, 1)).__call__, post_softmax=False),

    # ---- LRP series
    # "LRP-0-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=24)),  # for vgg16
    # "LRP-0-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=17)),
    # "LRP-0-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=10)),
    # "LRP-0-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=5)),
    # "LRP-C-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init=None, method='lrpc', layer_num=24)), # for vgg16
    # "LRP-C-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init=None, method='lrpc', layer_num=17)),
    # "LRP-C-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init=None, method='lrpc', layer_num=10)),
    # "LRP-C-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init=None, method='lrpc', layer_num=5)),
    # "SG-LRP-0-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=24)),
    # "SG-LRP-0-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=17)),
    # "SG-LRP-0-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=10)),
    # "SG-LRP-0-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=5)),
    # "SG-LRP-ZP-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=24)),
    # "SG-LRP-ZP-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=17)),
    # "SG-LRP-ZP-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=10)),
    # "SG-LRP-ZP-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=5)),
    # "SIG-LRP-ZP-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer_num=24)),
    # "SIG-LRP-ZP-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer_num=17)),
    # "SIG-LRP-ZP-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer_num=10)),
    # "SIG-LRP-ZP-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer_num=5)),
    # "SIG-LRP-C-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=24)),
    # "SIG-LRP-C-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=17)),
    # "SIG-LRP-C-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=10)),
    # "SIG-LRP-C-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=5)),
    # ---- LID series
    # "ST-LID-Taylor-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=4, bp='st', linear=True),
    # "ST-LID-Taylor-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=3, bp='st', linear=True),
    # "ST-LID-Taylor-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=2, bp='st', linear=True),
    # "ST-LID-Taylor-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=1, bp='st', linear=True),
    # "ST-LID-IG-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=4, bp='st', linear=False),
    # "ST-LID-IG-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=3, bp='st', linear=False),
    # "ST-LID-IG-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=2, bp='st', linear=False),
    # "ST-LID-IG-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=1, bp='st', linear=False),
    # "LID-IG-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=4, bp=None, linear=False),
    # "LID-IG-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=3, bp=None, linear=False),
    # "LID-IG-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=2, bp=None, linear=False),
    # "LID-IG-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=1, bp=None, linear=False),
    "SIG-LID-Taylor-s4": method_caller(LID_wrapper, decode_stages_wrapper((4,)), LIN=1, BP='sig', GIP=0.0),
    "SIG-LID-Taylor-s3": method_caller(LID_wrapper, decode_stages_wrapper((3,)), LIN=1, BP='sig', GIP=0.0),
    "SIG-LID-Taylor-s2": method_caller(LID_wrapper, decode_stages_wrapper((2,)), LIN=1, BP='sig', GIP=0.0),
    "SIG-LID-Taylor-s1": method_caller(LID_wrapper, decode_stages_wrapper((1,)), LIN=1, BP='sig', GIP=0.0),
    "SIG-LID-IG-s4": method_caller(LID_wrapper, decode_stages_wrapper((4,)), LIN=0, BP='sig', GIP=0.0),
    "SIG-LID-IG-s3": method_caller(LID_wrapper, decode_stages_wrapper((3,)), LIN=0, BP='sig', GIP=0.0),
    "SIG-LID-IG-s2": method_caller(LID_wrapper, decode_stages_wrapper((2,)), LIN=0, BP='sig', GIP=0.0),
    "SIG-LID-IG-s1": method_caller(LID_wrapper, decode_stages_wrapper((1,)), LIN=0, BP='sig', GIP=0.0),
    "SIG-LID-IG-GIP-s4": method_caller(LID_wrapper, decode_stages_wrapper((4,)), LIN=0, BP='sig', GIP=0.3),
    "SIG-LID-IG-GIP-s3": method_caller(LID_wrapper, decode_stages_wrapper((3,)), LIN=0, BP='sig', GIP=0.3),
    "SIG-LID-IG-GIP-s2": method_caller(LID_wrapper, decode_stages_wrapper((2,)), LIN=0, BP='sig', GIP=0.3),
    "SIG-LID-IG-GIP-s1": method_caller(LID_wrapper, decode_stages_wrapper((1,)), LIN=0, BP='sig', GIP=0.3),

    # ============= pixel level heatmaps
    # -- LRP-0 noisy
    # "LRP-0-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=0)),
    # "LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpc', layer_num=0)),
    # "LRP-C-1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpc', layer_num=1)),
    # "C-LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='c', method='lrpc', layer_num=0)),
    # "C-LRP-C2-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='c', method='lrpc2', layer_num=0)),
    # "SG-LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpc', layer_num=0)),
    # "ST-LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='st', method='lrpc', layer_num=0)),
    # "SIG-LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=0)),
    # "IG-s0": lambda model: partial(IG(model, decode_stages(model, 0)).__call__, post_softmax=False),
    # "SIG-s0": lambda model: partial(IG(model, decode_stages(model, 0)).__call__, post_softmax=False),

    # -- nonsense
    # "LRP-Z-0": lambda model: lambda x, y: LRP_Generator(model)(
    #     x, y, backward_init='normal', method='lrpz', layer=0),
    # -- noisy
    # "S-LRP-C-1": lambda model: lambda x, y: LRP_Generator(model)(
    #     x, y, backward_init='normal', method='slrp', layer=1),
    # "S-LRP-C-0": lambda model: lambda x, y: LRP_Generator(model)(
    #     x, y, backward_init='normal', method='slrp', layer=0),
    # "LRP-ZP-0": lambda model: lambda x, y: LRP_Generator(model)(
    #     x, y, backward_init='normal', method='lrpzp', layer=0),
    # "SG-LRP-ZP-0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer=0)),
    # "ST-LRP-ZP-0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='st', method='lrpzp', layer=0)),

    # ----------- LID Increment Decomposition
    # unfortunately, s0 is bad
    # "LID-Taylor-s0": lambda model: lambda x, y: LID_m_caller(model, x, y, s=0, bp=None, lin=1),
    "SIG-LID-Taylor-s0": method_caller(LID_wrapper, decode_stages_wrapper((0, )), LIN=1, BP='sig'),
    "SIG-LID-IG-s0": method_caller(LID_wrapper, decode_stages_wrapper((0, )), LIN=0, BP='sig'),
    "SIG-LID-IG-s0-GIP": method_caller(LID_wrapper, decode_stages_wrapper((0, )), LIN=0, BP='sig', GIP=0.3),

    # =============== mix scale features
    # "LayerCAM-s54": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4))).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s543": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4, 3))).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s5432": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4, 3, 2))).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s54321": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4, 3, 2, 1))).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "SG-LayerCAM-origin-s54321": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4, 3, 2, 1))).__call__,
    #                                          post_softmax=True, relu_weight=False, relu=False),# bad
    # "SIG-LRP-C-s54": lambda model: lambda x, y: multi_interpolate(
    #     hm for i, hm in enumerate(LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=None)) if i in [17, 24, 31]),
    # "SIG-LRP-C-s543": lambda model: lambda x, y: multi_interpolate(
    #     hm for i, hm in enumerate(LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=None)) if i in [10, 17, 24, 31]),
    # "SIG-LRP-C-s5432": lambda model: lambda x, y: multi_interpolate(
    #     hm for i, hm in enumerate(LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=None)) if i in [5, 10, 17, 24, 31]),
    # "SIG-LRP-C-s54321": lambda model: lambda x, y: multi_interpolate(
    #     hm for i, hm in enumerate(LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=None)) if i in [1, 5, 10, 17, 24, 31]),
    # -- bad mix
    # "SIG-LID-Taylor-s54": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4), lin=1, bp='sig'),
    # "SIG-LID-Taylor-s543": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3), lin=1, bp='sig'),
    # "SIG-LID-Taylor-s5432": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3, 2), lin=1, bp='sig'),
    "SIG-LID-IG-GIP-s54": method_caller(LID_wrapper, decode_stages_wrapper((5, 4)), LIN=0, BP='sig', GIP=0.3, DF=1),
    "SIG-LID-IG-GIP-s543": method_caller(LID_wrapper, decode_stages_wrapper((5, 4, 3)), LIN=0, BP='sig', GIP=0.3, DF=1),
    "SIG-LID-IG-GIP-s5432": method_caller(LID_wrapper, decode_stages_wrapper((5, 4, 3, 2)), LIN=0, BP='sig', GIP=0.3, DF=1),
    "SIG-LID-IG-GIP-s54321": method_caller(LID_wrapper, decode_stages_wrapper((5, 4, 3, 2, 1)), LIN=0, BP='sig', GIP=0.3, DF=1),


}
