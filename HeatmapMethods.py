from functools import partial
import torch
import torch.nn.functional as nf

from methods.LRPG import LRPWithGradient
from utils import *
from methods.GradCAM import GradCAM
from methods.LayerCAM import LayerCAM
from methods.ScoreCAM import ScoreCAM
from methods.AblationCAM import AblationCAM
from methods.RelevanceCAM import RelevanceCAM
from methods.LRP import LRP_Generator
from methods.IG import IG
from methods.LIDDecomposer import *
from methods.SmoothTaylor import SmoothTaylor

# partial fun 参数是静态的，传了就不能变，此处要求每次访问self.model。（写下语句的时候就创建完了）
# lambda fun 是动态的，运行时解析
# 结合一下匿名lambda函数就可以实现 创建含动态参数(model)的partial fun，只多了一步调用()
def method_caller(method_class, *args, **kwargs):
    def method(model):
        method = method_class(model, **kwargs)
        return partial(method.__call__, **kwargs)

    return method


# cam_dict = lambda model, layer: {'arch': model, 'layer_name': layer}

# the method interface, all methods must follow this:
# the method can call twice
# 1. the method first accept "model" parameter, create a callable function "_m = m(model)"
# 2. the heatmap generated by secondly calling "hm = _m(x,yc)"
heatmap_methods = {
    "None": None,
    # ========= temp test

    # ============================== Top level features
    # using 5 stage to refer different model layers:
    # suppose input layer is layer 0, features_0 of vgg16 is layer 1
    # referring stage 0 as input layer
    # VGG: 012345-> 0,5,10,17,24,31
    # VGG stages in module features(convs): 4,9,16,23,30
    # ResNet: 12345-> mp,l1,l2,l3,l4
    # GoogleNet:...
    # -------------------------- CAM series
    "GradCAM-s5": lambda model: partial(GradCAM(model, decode_stages(model, 5)).__call__, post_softmax=False, relu=True),  # cam can not auto release, so use partial
    "GradCAM-origin-s5": lambda model: partial(GradCAM(model, decode_stages(model, 5)).__call__, post_softmax=False, relu=False),
    # "SG-GradCAM-origin-s5": lambda model: partial(GradCAM(model, decode_stages(model, 5)).__call__, post_softmax=True, relu=False),
    "LayerCAM-s5": lambda model: partial(LayerCAM(model, decode_stages(model, 5)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # --LayerCAM-origin-s5 == LRP-0-s5
    # "LayerCAM-origin-s5": lambda model: partial(LayerCAM(model, decode_stages(model, 5)).__call__, post_softmax=False, relu_weight=False, relu=False),
    # --SG-LayerCAM-origin-s5 == ST-LRP-0-s5
    # "SG-LayerCAM-origin-s5": lambda model: partial(LayerCAM(model, decode_stages(model, 5)).__call__,post_softmax=True, relu=False),
    "ScoreCAM-s5": lambda model: partial(ScoreCAM(model, decode_stages(model, 5)).__call__, post_softmax=True, relu=False),
    # "ScoreCAMpp-s5": lambda model: partial(ScoreCAM(model, decode_stages(model, 5)).__call__, post_softmax=False, relu=False, pp=True),
    # "ScoreCAMgpp-s5": lambda model: partial(ScoreCAM(model, decode_stages(model, 5)).__call__, post_softmax=True, relu=False, pp=True),
    # ----------------- others
    # "Random": lambda model: lambda x, y: heatmapNormalizeR(torch.randn((1,) + x.shape[-2:])),
    "AblationCAM-s5": lambda model: lambda x, y: AblationCAM(model, -1)(x, y, relu=False),
    "RelevanceCAM-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        RelevanceCAM(model)(x, y, backward_init='c', method='lrpzp', layer_num=-1)),
    # -- IG
    "IG-s5": lambda model: partial(IG(model, decode_stages(model, 5)).__call__, post_softmax=False),
    "SIG-s5": lambda model: partial(IG(model, decode_stages(model, 5)).__call__, post_softmax=True),
    # "SmoothTaylor-s5": lambda model: partial(SmoothTaylor(model, decode_stages(model, 5)).__call__, post_softmax=False),

    # ---------------------------- LRP series
    "LRP-0-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=31)),
    # -- LRP-C use LRP-0 in classifier, they are equivalent.
    # "LRP-C-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpc', layer_num=31)),
    # -- LRP-Z is nonsense
    # "LRP-Z-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpz', layer=-1)),
    # -- LRP-ZP has no edge highlight, but lack class discrimination
    "LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='normal', method='lrpzp', layer_num=-1)),
    # -- LRP-W2 all red
    # "LRP-W2-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpw2', layer=-1)),
    # -- Contrastive LRP (C-LRP) to bad often loss discrimination
    # "C-LRP-C-s5": lambda model: lambda x, y: interpolate_to_imgsize(  # c is unstable
    #     LRP_Generator(model)(x, y, backward_init='c', method='lrpc', layer_num=31)),
    "C-LRP-C2-s5": lambda model: lambda x, y: interpolate_to_imgsize(  # c2 is stable, interesting.
        LRP_Generator(model)(x, y, backward_init='c', method='lrpc2', layer_num=31)),
    # "C-LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='c', method='lrpzp', layer=31)),
    "SG-LRP-0-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=-1)),
    "SG-LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=31)),

    # ----------- new LID (Layer-wise Increment Decomposition) series
    # ----------- method improvement: increment(in middle/top), contrast(in top), nonlinearity(in middle/top)
    # -- LID series name convention: Init-LID-Type-Layer.
    # -- SIG-LID-Taylor-s5 means it is linear decompose, given sig init, ending at top feature layer
    # -- middle: increment, top: none
    "LID-Taylor-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, s=5, bp=None, lin=1),
    # -- middle: nonlinear increment
    "LID-IG-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, s=5, bp=None, lin=0),
    # -- top: contrastive increment, middle: increment
    # "ST-LID-Taylor-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=5, bp='st', linear=True),
    # -- top: contrastive increment, middle: nonlinear increment
    # "ST-LID-IG-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=5, bp='st', linear=False),
    # -- top: nonlinear contrastive increment, middle: increment
    "SIG-LID-Taylor-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, s=5, bp='sig', lin=1),
    # -- full mixed, top: nonlinear contrastive increment, middle: nonlinear increment
    "SIG-LID-IG-s5": lambda model: lambda x, y: LID_m_caller(model, x, y, s=5, bp='sig', lin=0),

    # ------ LRP is in LID with reference point Y^L=0
    # -- contrastive increment
    "ST-LRP-C-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='st', method='lrpc', layer_num=-1)),
    # -- nonlinear contrastive increment, full nonlinear contrast but not increment in middle
    "SIG-LRP-C-s5": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=-1)),
    # -- LRP cannot use nonlinear in middle.
    # "LRP-IG-s5": lambda model: lambda x, y: interpolate_to_imgsize(  # unstable all layers due to low values
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpig', layer=-1)),
    # "SIG-LRP-IG-s5": lambda model: lambda x, y: interpolate_to_imgsize(  # unstable
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpig', layer=-1)),

    # "ST-LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='st', method='lrpzp', layer=31)),
    # "SIG-LRP-ZP-s5": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer=-1)),



    # ===================== Middle level features
    # --------------- cam series
    # -- GradCAM s4 is nonsense
    # "GradCAM-s4": lambda model: partial(GradCAM(model, decode_stages(model, 4)).__call__, post_softmax=False, relu=True),
    # "GradCAM-s3": lambda model: partial(GradCAM(model, decode_stages(model, 3)).__call__, post_softmax=False, relu=True),
    # "GradCAM-s2": lambda model: partial(GradCAM(model, decode_stages(model, 2)).__call__, post_softmax=False, relu=True),
    # "GradCAM-s1": lambda model: partial(GradCAM(model, decode_stages(model, 1)).__call__, post_softmax=False, relu=True),
    # "GradCAM-origin-s4": lambda model: partial(GradCAM(model, decode_stages(model, 4)).__call__,post_softmax=False, relu=False),
    # "SG-GradCAM-origin-s4": lambda model: partial(GradCAM(model, decode_stages(model, 4)).__call__,post_softmax=True, relu=False),
    # "LayerCAM-s4": lambda model: partial(LayerCAM(model, decode_stages(model, 4)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s3": lambda model: partial(LayerCAM(model, decode_stages(model, 3)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s2": lambda model: partial(LayerCAM(model, decode_stages(model, 2)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-s1": lambda model: partial(LayerCAM(model, decode_stages(model, 1)).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "LayerCAM-origin-s4": lambda model: partial(LayerCAM(model, decode_stages(model, 4)).__call__,post_softmax=False, relu=False),
    # "LayerCAM-origin-s3": lambda model: partial(LayerCAM(model, decode_stages(model, 3))).__call__,post_softmax=False, relu=False),
    # "LayerCAM-origin-s2": lambda model: partial(LayerCAM(model, decode_stages(model, 2))).__call__,post_softmax=False, relu=False),
    # "LayerCAM-origin-s1": lambda model: partial(LayerCAM(model, decode_stages(model, 1))).__call__,post_softmax=False, relu=False),
    # "SG-LayerCAM-origin-s4": lambda model: partial(LayerCAM(model, decode_stages(model, 4))).__call__,post_softmax=True, relu=False),
    # "SG-LayerCAM-origin-s3": lambda model: partial(LayerCAM(model, decode_stages(model, 3))).__call__,post_softmax=True, relu=False),
    # "SG-LayerCAM-origin-s2": lambda model: partial(LayerCAM(model, decode_stages(model, 2))).__call__,post_softmax=True, relu=False),
    # "SG-LayerCAM-origin-s1": lambda model: partial(LayerCAM(model, decode_stages(model, 1))).__call__,post_softmax=True, relu=False),
    # "ScoreCAM-s4": lambda model: partial(ScoreCAM(model, decode_stages(model, 4)).__call__, post_softmax=True, relu=False),
    # "ScoreCAM-s3": lambda model: partial(ScoreCAM(model, decode_stages(model, 3)).__call__, post_softmax=True, relu=False),
    # "ScoreCAM-s2": lambda model: partial(ScoreCAM(model, decode_stages(model, 2)).__call__, post_softmax=True, relu=False),
    # "ScoreCAM-s1": lambda model: partial(ScoreCAM(model, decode_stages(model, 1)).__call__, post_softmax=True, relu=False),
    # -- lower layer ig is bad
    # "IG-s4": lambda model: partial(IG(model, decode_stages(model, 4)).__call__, post_softmax=False),
    # "IG-s3": lambda model: partial(IG(model, decode_stages(model, 3)).__call__, post_softmax=False),
    # "IG-s2": lambda model: partial(IG(model, decode_stages(model, 2)).__call__, post_softmax=False),
    # "IG-s1": lambda model: partial(IG(model, decode_stages(model, 1)).__call__, post_softmax=False),
    # "SIG-s4": lambda model: partial(IG(model, decode_stages(model, 4)).__call__, post_softmax=True),
    # "SIG-s3": lambda model: partial(IG(model, decode_stages(model, 3)).__call__, post_softmax=True),
    # "SIG-s2": lambda model: partial(IG(model, decode_stages(model, 2)).__call__, post_softmax=True),
    # "SIG-s1": lambda model: partial(IG(model, decode_stages(model, 1)).__call__, post_softmax=True),
    # also noisy at step=10. step=100 oom
    # "SmoothTaylor-s4": lambda model: partial(SmoothTaylor(model, decode_stages(model, 4)).__call__, post_softmax=False),
    # "SmoothTaylor-s3": lambda model: partial(SmoothTaylor(model, decode_stages(model, 3)).__call__, post_softmax=False),
    # "SmoothTaylor-s2": lambda model: partial(SmoothTaylor(model, decode_stages(model, 2)).__call__, post_softmax=False),
    # "SmoothTaylor-s1": lambda model: partial(SmoothTaylor(model, decode_stages(model, 1)).__call__, post_softmax=False),

    # ---- LRP series
    # "LRP-0-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=24)),  # for vgg16
    # "LRP-0-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=17)),
    # "LRP-0-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=10)),
    # "LRP-0-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=5)),
    # "LRP-C-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init=None, method='lrpc', layer_num=24)), # for vgg16
    # "LRP-C-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init=None, method='lrpc', layer_num=17)),
    # "LRP-C-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init=None, method='lrpc', layer_num=10)),
    # "LRP-C-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init=None, method='lrpc', layer_num=5)),
    # "SG-LRP-0-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=24)),
    # "SG-LRP-0-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=17)),
    # "SG-LRP-0-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=10)),
    # "SG-LRP-0-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrp0', layer_num=5)),
    # "SG-LRP-ZP-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=24)),
    # "SG-LRP-ZP-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=17)),
    # "SG-LRP-ZP-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=10)),
    # "SG-LRP-ZP-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer_num=5)),
    # "SIG-LRP-ZP-s4": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer_num=24)),
    # "SIG-LRP-ZP-s3": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer_num=17)),
    # "SIG-LRP-ZP-s2": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer_num=10)),
    # "SIG-LRP-ZP-s1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sig', method='lrpzp', layer_num=5)),
    "SIG-LRP-C-s4": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=24)),
    "SIG-LRP-C-s3": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=17)),
    "SIG-LRP-C-s2": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=10)),
    "SIG-LRP-C-s1": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=5)),
    # ---- LID series
    # "ST-LID-Taylor-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=4, bp='st', linear=True),
    # "ST-LID-Taylor-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=3, bp='st', linear=True),
    # "ST-LID-Taylor-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=2, bp='st', linear=True),
    # "ST-LID-Taylor-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=1, bp='st', linear=True),
    # "ST-LID-IG-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=4, bp='st', linear=False),
    # "ST-LID-IG-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=3, bp='st', linear=False),
    # "ST-LID-IG-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=2, bp='st', linear=False),
    # "ST-LID-IG-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=1, bp='st', linear=False),
    # "LID-IG-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=4, bp=None, linear=False),
    # "LID-IG-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=3, bp=None, linear=False),
    # "LID-IG-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=2, bp=None, linear=False),
    # "LID-IG-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, stages=1, bp=None, linear=False),
    "SIG-LID-Taylor-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, s=4, bp='sig', lin=1),
    "SIG-LID-Taylor-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, s=3, bp='sig', lin=1),
    "SIG-LID-Taylor-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, s=2, bp='sig', lin=1),
    "SIG-LID-Taylor-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, s=1, bp='sig', lin=1),
    "SIG-LID-IG-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, s=4, bp='sig', lin=0),
    "SIG-LID-IG-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, s=3, bp='sig', lin=0),
    "SIG-LID-IG-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, s=2, bp='sig', lin=0),
    "SIG-LID-IG-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, s=1, bp='sig', lin=0),
    # "SIG-LID-IG-CE02-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, s=4, bp='sig', lin=0, ce=0.2),
    # "SIG-LID-IG-CE05-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, s=4, bp='sig', lin=0, ce=0.5),
    # "SIG-LID-IG-CE10-s4": lambda model: lambda x, y: LID_m_caller(model, x, y, s=4, bp='sig', lin=0, ce=1.0),
    # "SIG-LID-IG-CE05-s3": lambda model: lambda x, y: LID_m_caller(model, x, y, s=3, bp='sig', lin=0, ce=0.5),
    # "SIG-LID-IG-CE05-s2": lambda model: lambda x, y: LID_m_caller(model, x, y, s=2, bp='sig', lin=0, ce=0.5),
    # "SIG-LID-IG-CE05-s1": lambda model: lambda x, y: LID_m_caller(model, x, y, s=1, bp='sig', lin=0, ce=0.5),

    # ============= pixel level heatmaps
    # -- LRP-0 noisy
    # "LRP-0-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrp0', layer_num=0)),
    # "LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpc', layer_num=0)),
    # "LRP-C-1": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='normal', method='lrpc', layer_num=1)),
    # "C-LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='c', method='lrpc', layer_num=0)),
    # "C-LRP-C2-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='c', method='lrpc2', layer_num=0)),
    # "SG-LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpc', layer_num=0)),
    # "ST-LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='st', method='lrpc', layer_num=0)),
    "SIG-LRP-C-s0": lambda model: lambda x, y: interpolate_to_imgsize(
        LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=0)),
    # "IG-s0": lambda model: partial(IG(model, decode_stages(model, 0)).__call__, post_softmax=False),
    # "SIG-s0": lambda model: partial(IG(model, decode_stages(model, 0)).__call__, post_softmax=False),

    # -- nonsense
    # "LRP-Z-0": lambda model: lambda x, y: LRP_Generator(model)(
    #     x, y, backward_init='normal', method='lrpz', layer=0),
    # -- noisy
    # "S-LRP-C-1": lambda model: lambda x, y: LRP_Generator(model)(
    #     x, y, backward_init='normal', method='slrp', layer=1),
    # "S-LRP-C-0": lambda model: lambda x, y: LRP_Generator(model)(
    #     x, y, backward_init='normal', method='slrp', layer=0),
    # "LRP-ZP-0": lambda model: lambda x, y: LRP_Generator(model)(
    #     x, y, backward_init='normal', method='lrpzp', layer=0),
    # "SG-LRP-ZP-0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='sg', method='lrpzp', layer=0)),
    # "ST-LRP-ZP-0": lambda model: lambda x, y: interpolate_to_imgsize(
    #     LRP_Generator(model)(x, y, backward_init='st', method='lrpzp', layer=0)),

    # ----------- LID Increment Decomposition
    # unfortunately, s0 is bad
    "LID-Taylor-s0": lambda model: lambda x, y: LID_m_caller(model, x, y, s=0, bp=None, lin=1),
    "SIG-LID-Taylor-s0": lambda model: lambda x, y: LID_m_caller(model, x, y, s=0, bp='sig', lin=1),
    "SIG-LID-IG-s0": lambda model: lambda x, y: LID_m_caller(model, x, y, s=0, bp='sig', lin=0),

    # =============== mix scale features
    "LayerCAM-s54": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4))).__call__, post_softmax=False, relu_weight=True, relu=True),
    "LayerCAM-s543": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4, 3))).__call__, post_softmax=False, relu_weight=True, relu=True),
    "LayerCAM-s5432": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4, 3, 2))).__call__, post_softmax=False, relu_weight=True, relu=True),
    "LayerCAM-s54321": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4, 3, 2, 1))).__call__, post_softmax=False, relu_weight=True, relu=True),
    # "SG-LayerCAM-origin-s54321": lambda model: partial(LayerCAM(model, decode_stages(model, (5, 4, 3, 2, 1))).__call__,
    #                                          post_softmax=True, relu_weight=False, relu=False),# bad
    "SIG-LRP-C-s54": lambda model: lambda x, y: multi_interpolate(
        hm for i, hm in enumerate(LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=None)) if i in [17, 24, 31]),
    "SIG-LRP-C-s543": lambda model: lambda x, y: multi_interpolate(
        hm for i, hm in enumerate(LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=None)) if i in [10, 17, 24, 31]),
    "SIG-LRP-C-s5432": lambda model: lambda x, y: multi_interpolate(
        hm for i, hm in enumerate(LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=None)) if i in [5, 10, 17, 24, 31]),
    "SIG-LRP-C-s54321": lambda model: lambda x, y: multi_interpolate(
        hm for i, hm in enumerate(LRP_Generator(model)(x, y, backward_init='sig', method='lrpc', layer_num=None)) if i in [1, 5, 10, 17, 24, 31]),
    # -- bad mix
    "SIG-LID-Taylor-s54": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4), lin=1, bp='sig'),
    "SIG-LID-Taylor-s543": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3), lin=1, bp='sig'),
    "SIG-LID-Taylor-s5432": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3, 2), lin=1, bp='sig'),
    "SIG-LID-IG-s54": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4), lin=0, bp='sig'),
    "SIG-LID-IG-s543": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3), lin=0, bp='sig'),
    "SIG-LID-IG-s5432": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3, 2), lin=0, bp='sig'),
    "SIG-LID-IG-s54321": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3, 2, 1), lin=0, bp='sig'),

    # "SIG-LID-Taylor-CE05-s54": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4), bp='sig', lin=1, ce=0.5),
    # "SIG-LID-Taylor-CE05-s543": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3),bp='sig',lin=1,ce=0.5),
    # "SIG-LID-Taylor-CE05-s5432": lambda model: lambda x, y: LID_m_caller(model, x, y,s=(5,4,3,2),bp='sig',lin=1,ce=0.5),
    # "SIG-LID-Taylor-CE05-s54321": lambda model: lambda x, y:LID_m_caller(model,x,y,s=(5,4,3,2,1),bp='sig',lin=1,ce=0.5),
    # "SIG-LID-IG-CE05-s54": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4), bp='sig', lin=0, ce=0.5),
    # "SIG-LID-IG-CE05-s543": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5, 4, 3), bp='sig', lin=0, ce=0.5),
    # "SIG-LID-IG-CE05-s5432": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5,4,3,2), bp='sig', lin=0, ce=0.5),
    # "SIG-LID-IG-CE05-s54321": lambda model: lambda x, y: LID_m_caller(model, x, y, s=(5,4,3,2,1),bp='sig',lin=0,ce=0.5),

}
